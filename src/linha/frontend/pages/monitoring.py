import streamlit as st
import cv2
from datetime import datetime
import pandas as pd
import logging
from linha.frontend.api_client import APIClient
import time

logger = logging.getLogger(__name__)

def render_monitoring_page(api_client):
    """Renderiza p√°gina de monitoramento"""
    
    st.title("Monitoramento do Sistema")
    
    # Tabs fixas
    tab1, tab2, tab3 = st.tabs(["C√¢meras", "Processamento", "Detec√ß√µes"])
    
    # Criar containers FORA do loop
    with tab1:
        cameras_container = st.empty()
    
    with tab2:
        processor_container = st.empty()
    
    with tab3:
        detections_container = st.empty()
    
    # Intervalo de atualiza√ß√£o
    update_interval = st.sidebar.slider("Intervalo (segundos)", 1, 10, 2)
    
    try:
        while True:
            # Atualizar conte√∫do das c√¢meras
            with cameras_container.container():
                status = api_client.get_capture_status()
                if 'error' in status:
                    st.error(f"‚ùå {status['error']}")
                else:
                    col1, col2, col3 = st.columns(3)
                    with col1:
                        st.metric("Sistema", "‚úÖ Online" if status['system_running'] else "‚ùå Offline")
                    with col2:
                        st.metric("C√¢meras", "‚úÖ OK" if status['cameras_configured'] else "‚ùå Erro")
                    with col3:
                        st.metric("Captura", "‚úÖ Ativa" if status['is_capturing'] else "‚ùå Parada")
                    
                    cameras = status.get('cameras', {})
                    for camera_id, camera in cameras.items():
                        st.markdown("---")
                        line_id = camera_id.split('_usb_')[0]
                        st.subheader(f"Linha: {line_id}")
                        
                        cols = st.columns(5)
                        cols[0].markdown("**C√¢mera**")
                        cols[0].write(camera['name'])
                        
                        cols[1].markdown("**Status**")
                        cols[1].success("‚úÖ Configurada") if camera['is_configured'] else cols[1].error("‚ùå Erro")
                        
                        cols[2].markdown("**Captura**")
                        cols[2].success("‚úÖ OK") if camera['can_capture'] else cols[2].error("‚ùå Erro")
                        
                        cols[3].markdown("**√öltima Imagem**")
                        last_capture = camera.get('last_image_time')
                        if last_capture:
                            now = datetime.now()
                            last_time = datetime.fromisoformat(last_capture)
                            diff = now - last_time
                            if diff.total_seconds() < 60:
                                cols[3].success(f"‚úÖ {diff.seconds}s atr√°s")
                            else:
                                cols[3].warning(f"‚ö†Ô∏è {diff.seconds//60}min atr√°s")
                        else:
                            cols[3].write("üïí Aguardando...")
                        
                        cols[4].markdown("**FPS**")
                        cols[4].metric("", f"{camera.get('fps', 0):.1f}")
            
            # Limpar e atualizar conte√∫do do processamento
            processor_container.empty()
            with processor_container.container():
                processor_status = api_client.get_processor_status()
                if 'error' in processor_status:
                    st.error(f"‚ùå {processor_status['error']}")
                else:
                    col1, col2, col3 = st.columns(3)
                    with col1:
                        st.metric("Lotes Pendentes", processor_status.get('pending_batches', 0))
                    with col2:
                        st.metric("Em Processamento", processor_status.get('processing_batches', 0))
                    with col3:
                        st.metric("Processados", processor_status.get('completed_batches', 0))
            
            # Limpar e atualizar conte√∫do das detec√ß√µes
            detections_container.empty()
            with detections_container.container():
                st.subheader("√öltimas Detec√ß√µes")
                
                # Filtros com keys √∫nicas
                col1, col2 = st.columns(2)
                with col1:
                    selected_line = st.selectbox(
                        "Linha de Produ√ß√£o",
                        options=["Todas"] + list(cameras.keys()),
                        key=f"detections_line_select_{int(time.time())}"
                    )
                with col2:
                    days = st.number_input(
                        "√öltimos dias", 
                        min_value=1, 
                        value=7,
                        key=f"days_input_{int(time.time())}"
                    )
                    
                # Buscar detec√ß√µes
                detections = processor_status.get('recent_detections', [])
                
                if not detections:
                    st.info("Nenhuma detec√ß√£o encontrada")
                else:
                    # Criar dataframe
                    data = []
                    for det in detections:
                        # Filtrar por linha se selecionada
                        if selected_line != "Todas" and det.get('line_id') != selected_line:
                            continue
                            
                        # Verificar se tem detec√ß√µes
                        if 'detections' in det and det['detections']:
                            for person in det['detections']:
                                data.append({
                                    "Data/Hora": datetime.fromisoformat(det['timestamp']).strftime("%d/%m/%Y %H:%M"),
                                    "Linha": det.get('line_id', 'N/A'),
                                    "C√¢mera": det.get('camera_id', 'N/A'),
                                    "Funcion√°rio": person.get('name', 'Desconhecido'),
                                    "Confian√ßa": f"{person.get('confidence', 0):.1%}"
                                })
                    
                    if data:
                        df = pd.DataFrame(data)
                        st.dataframe(df, hide_index=True)
                        
                        # Estat√≠sticas
                        st.markdown("---")
                        st.subheader("Estat√≠sticas")
                        
                        col1, col2 = st.columns(2)
                        
                        # Total por linha
                        with col1:
                            by_line = df["Linha"].value_counts()
                            st.bar_chart(by_line)
                            st.write("Detec√ß√µes por Linha")
                        
                        # Total por funcion√°rio
                        with col2:
                            by_employee = df["Funcion√°rio"].value_counts().head(10)
                            st.bar_chart(by_employee)
                            st.write("Top 10 Funcion√°rios")
                    else:
                        st.info("Nenhuma detec√ß√£o encontrada para os filtros selecionados")
            
            time.sleep(update_interval)
            
    except Exception as e:
        st.error(f"Erro no monitoramento: {str(e)}") 